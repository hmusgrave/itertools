I'm writing some code in the Zig programming language, and I'll be asking for your help.

Specifically, I'm writing an "itertools" library. Iterators in Zig are struct instances with a `next` method, returning `null` when no data remains. This library is special because it computes the final iteration type at compile time, inlining _all_ the intermediate `next()` calls and other bookkeeping.

It's partially complete, and I'll be asking for help writing function definitions, struct definitions, and tests. Do you have additional questions right away, or may I continue by giving you some example code?

To start with, here are the contents of "create.zig." The only thing we want to export here is the `pub fn iterate` function, which takes things one might want to iterate over as input (arrays, slices, vectors, other iterators, objects with methods capable of returning iterators, ...), and returns an iterator wrapping them. It uses the "zkwargs" library to allow a little compile-time specialization like choosing whether one wishes to iterate by reference or by value.


[[create.zig]]

Not bad. I already have an `iterate` function though, and I'm just telling you about the file. Please learn from it what you can, and I'll continue giving you examples. I'm going to continue with the main file (which uses "create.zig" for initialization). I have many kinds of iterators already written including ScanT and FilterMapT (called by `scan` and `filter_map`, respectively). Note how the code has functions generating types at compile time instead of directly iterating over values.

[[main.zig]]

Exactly. Now the last thing before I start asking specific questions, here's a brain dump of ideas I'm using while figuring out what to code next. It has some notes that might be useful.

[[TODO.md]]

I do have specific questions, thank you. To start with, please implement
[[FooT]] in the style of `ScanT`, `MapT`, `FilterMapT`, and the other existing iterator generators.

Not bad. You didn't finish the function though. Here are some other examples
you can look at to get a better feel for what I'm looking for. Then please
write a complete [[FooT]] implementation in impeccable Zig in a single code block. Do not write an explanation.

[[ScanT, MapT, ...]]

Perfect (though you didn't need the `result` variable). Now please write a
[[foo]] method calling [[FooT]] It should have the same style as the following example methods.

[[scan, map, ...]]
